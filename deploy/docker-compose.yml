version: '3.8'

services:
  proxy:
    image: traefik:v3.0
    # Load environment variables from .env file
    env_file:
      - .env
    networks:
      # Attach to Traefik's public network and default network
      - ${TRAEFIK_PUBLIC_NETWORK?Variable not set}
      - default
    volumes:
      # Provide access to Docker socket for Traefik
      - /var/run/docker.sock:/var/run/docker.sock
    command:
      # Enable Docker provider and set constraints for stack-specific rules
      - --providers.docker
      - --providers.docker.constraints=Label(`traefik.constraint-label-stack`, `${TRAEFIK_TAG?Variable not set}`)
      - --providers.docker.exposedbydefault=false
      - --accesslog
      - --log
      - --api
    deploy:
      placement:
        # Ensure the service only runs on manager nodes
        constraints:
          - node.role == manager
      labels:
        # Traefik-specific labels to enable routing and SSL termination
        - traefik.enable=true
        - traefik.docker.network=${TRAEFIK_PUBLIC_NETWORK?Variable not set}
        - traefik.constraint-label=${TRAEFIK_PUBLIC_TAG?Variable not set}
        # Middleware to redirect HTTP to HTTPS
        - traefik.http.middlewares.${STACK_NAME?Variable not set}-https-redirect.redirectscheme.scheme=https
        - traefik.http.middlewares.${STACK_NAME?Variable not set}-https-redirect.redirectscheme.permanent=true
        # Define HTTP and HTTPS routers
        - traefik.http.routers.${STACK_NAME?Variable not set}-proxy-http.rule=Host(`${DOMAIN?Variable not set}`) || Host(`www.${DOMAIN?Variable not set}`)
        - traefik.http.routers.${STACK_NAME?Variable not set}-proxy-http.entrypoints=http
        - traefik.http.routers.${STACK_NAME?Variable not set}-proxy-https.rule=Host(`${DOMAIN?Variable not set}`) || Host(`www.${DOMAIN?Variable not set}`)
        - traefik.http.routers.${STACK_NAME?Variable not set}-proxy-https.entrypoints=https
        - traefik.http.routers.${STACK_NAME?Variable not set}-proxy-https.tls=true
        - traefik.http.routers.${STACK_NAME?Variable not set}-proxy-https.tls.certresolver=le
        # Backend service port configuration
        - traefik.http.services.${STACK_NAME?Variable not set}-proxy.loadbalancer.server.port=80
        # Redirect www to non-www URLs
        - traefik.http.middlewares.${STACK_NAME?Variable not set}-www-redirect.redirectregex.regex=^https?://(www.)?(${DOMAIN?Variable not set})/(.*)
        - traefik.http.middlewares.${STACK_NAME?Variable not set}-www-redirect.redirectregex.replacement=https://${DOMAIN?Variable not set}/$${3}
        # Apply middlewares for redirects
        - traefik.http.routers.${STACK_NAME?Variable not set}-proxy-https.middlewares=${STACK_NAME?Variable not set}-www-redirect
        - traefik.http.routers.${STACK_NAME?Variable not set}-proxy-http.middlewares=${STACK_NAME?Variable not set}-www-redirect,${STACK_NAME?Variable not set}-https-redirect

  # Backend service for the application (Langflow backend)
  backend: &backend
    image: "langflowai/langflow-backend:latest"
    depends_on:
      - db
      - broker
      - result_backend
    env_file:
      - .env
    healthcheck:
      # Skip healthcheck for demo purposes (replace with actual command as needed)
      test: "exit 0"
    deploy:
      labels:
        # Enable Traefik routing for the backend service
        - traefik.enable=true
        - traefik.constraint-label-stack=${TRAEFIK_TAG?Variable not set}
        # Define HTTP routing rules for API, docs, and health endpoints
        - traefik.http.routers.${STACK_NAME?Variable not set}-backend-http.rule=PathPrefix(`/api/v1`) || PathPrefix(`/docs`) || PathPrefix(`/health`)
        - traefik.http.services.${STACK_NAME?Variable not set}-backend.loadbalancer.server.port=7860

  # PostgreSQL database service
  db:
    image: postgres:15.4
    volumes:
      # Use persistent storage for PostgreSQL data
      - app-db-data:/var/lib/postgresql/data/pgdata
    environment:
      - PGDATA=/var/lib/postgresql/data/pgdata
    deploy:
      placement:
        # Constraint to run the database on a node with the app-db-data label
        constraints:
          - node.labels.app-db-data == true
    healthcheck:
      test: "exit 0"
    env_file:
      - .env

  # pgAdmin service for managing PostgreSQL
  pgadmin:
    image: dpage/pgadmin4
    networks:
      # Attach to Traefik's public network and default network
      - ${TRAEFIK_PUBLIC_NETWORK?Variable not set}
      - default
    volumes:
      # Use persistent storage for pgAdmin data
      - pgadmin-data:/var/lib/pgadmin
    env_file:
      - .env
    deploy:
      labels:
        # Traefik configuration for pgAdmin routing
        - traefik.enable=true
        - traefik.docker.network=${TRAEFIK_PUBLIC_NETWORK?Variable not set}
        - traefik.constraint-label=${TRAEFIK_PUBLIC_TAG?Variable not set}
        - traefik.http.routers.${STACK_NAME?Variable not set}-pgadmin-http.rule=Host(`pgadmin.${DOMAIN?Variable not set}`)
        - traefik.http.routers.${STACK_NAME?Variable not set}-pgadmin-http.entrypoints=http
        - traefik.http.routers.${STACK_NAME?Variable not set}-pgadmin-http.middlewares=${STACK_NAME?Variable not set}-https-redirect
        - traefik.http.routers.${STACK_NAME?Variable not set}-pgadmin-https.rule=Host(`pgadmin.${DOMAIN?Variable not set}`)
        - traefik.http.routers.${STACK_NAME?Variable not set}-pgadmin-https.entrypoints=https
        - traefik.http.routers.${STACK_NAME?Variable not set}-pgadmin-https.tls=true
        - traefik.http.routers.${STACK_NAME?Variable not set}-pgadmin-https.tls.certresolver=le
        - traefik.http.services.${STACK_NAME?Variable not set}-pgadmin.loadbalancer.server.port=5050

  # Redis service for result backend in Celery
  result_backend:
    image: redis:6.2.5
    env_file:
      - .env
    ports:
      # Expose Redis default port
      - 6379:6379
    healthcheck:
      test: "exit 0"

  # Celery worker for background tasks (concurrent processing)
  celeryworker:
    <<: *backend
    env_file:
      - .env
    command: /bin/sh -c "python -m celery -A langflow.worker.celery_app worker --loglevel=INFO --concurrency=1 -n lf-worker@%h -P eventlet"
    healthcheck:
      test: "exit 0"
    deploy:
      replicas: 1

  # Flower service for monitoring Celery tasks
  flower:
    <<: *backend
    env_file:
      - .env
    networks:
      - default
    environment:
      - FLOWER_PORT=5555
    command: /bin/sh -c "python -m celery -A langflow.worker.celery_app --broker=${BROKER_URL?Variable not set} flower --port=5555"
    deploy:
      labels:
        # Traefik routing configuration for Flower
        - traefik.enable=true
        - traefik.docker.network=${TRAEFIK_PUBLIC_NETWORK?Variable not set}
        - traefik.constraint-label=${TRAEFIK_PUBLIC_TAG?Variable not set}
        - traefik.http.routers.${STACK_NAME?Variable not set}-flower-http.rule=Host(`flower.${DOMAIN?Variable not set}`)
        - traefik.http.routers.${STACK_NAME?Variable not set}-flower-http.entrypoints=http
        - traefik.http.routers.${STACK_NAME?Variable not set}-flower-http.middlewares=${STACK_NAME?Variable not set}-https-redirect
        - traefik.http.routers.${STACK_NAME?Variable not set}-flower-https.rule=Host(`flower.${DOMAIN?Variable not set}`)
        - traefik.http.routers.${STACK_NAME?Variable not set}-flower-https.entrypoints=https
        - traefik.http.routers.${STACK_NAME?Variable not set}-flower-https.tls=true
        - traefik.http.routers.${STACK_NAME?Variable not set}-flower-https.tls.certresolver=le
        - traefik.http.services.${STACK_NAME?Variable not set}-flower.loadbalancer.server.port=5555

  # Frontend service (Langflow UI)
  frontend:
    image: "langflowai/langflow-frontend:latest"
    env_file:
      - .env
    restart: on-failure
    deploy:
      labels:
        # Enable routing for frontend through Traefik
        - traefik.enable=true
        - traefik.docker.network=${TRAEFIK_PUBLIC_NETWORK?Variable not set}
        - traefik.constraint-label=${TRAEFIK_PUBLIC_TAG?Variable not set}
        - traefik.http.routers.${STACK_NAME?Variable not set}-frontend-http.rule=Host(`${DOMAIN?Variable not set}`)
        - traefik.http.routers.${STACK_NAME?Variable not set}-frontend-http.entrypoints=http
        - traefik.http.routers.${STACK_NAME?Variable not set}-frontend-http.middlewares=${STACK_NAME?Variable not set}-https-redirect
        - traefik.http.routers.${STACK_NAME?Variable not set}-frontend-https.rule=Host(`${DOMAIN?Variable not set}`)
        - traefik.http.routers.${STACK_NAME?Variable not set}-frontend-https.entrypoints=https
        - traefik.http.routers.${STACK_NAME?Variable not set}-frontend-https.tls=true
        - traefik.http.routers.${STACK_NAME?Variable not set}-frontend-https.tls.certresolver=le
        - traefik.http.services.${STACK_NAME?Variable not set}-frontend.loadbalancer.server.port=8080

  # Prometheus service for monitoring metrics
  prometheus:
    image: prom/prometheus:latest
    env_file:
      - .env
    command:
      # Prometheus custom config file
      - --config.file=/etc/prometheus/prometheus.yml
    deploy:
      labels:
        # Enable Prometheus metrics through Traefik
        - traefik.enable=true
        - traefik.docker.network=${TRAEFIK_PUBLIC_NETWORK?Variable not set}
        - traefik.constraint-label=${TRAEFIK_PUBLIC_TAG?Variable not set}
        - traefik.http.routers.${STACK_NAME?Variable not set}-prometheus-http.rule=Host(`${DOMAIN?Variable not set}`)
        - traefik.http.services.${STACK_NAME?Variable not set}-prometheus.loadbalancer.server.port=9090

volumes:
  # Persistent volumes for database and application data
  app-db-data:
  pgadmin-data:
  rabbitmq_data:
  rabbitmq_log:

networks:
  # Default and public network configurations
  default:
    external: false
  ${TRAEFIK_PUBLIC_NETWORK?Variable not set}:
    external: true

#Modular Structure: Used YAML anchors for the backend configuration to avoid repeating code for services using the same base setup.
#Error Prevention: Catch unset variables during deployment to avoid misconfigurations.
#Persistent Volumes: Each service that stores data uses persistent volumes, ensuring data is not lost when containers restart.
